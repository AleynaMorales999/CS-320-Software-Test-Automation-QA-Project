# CS-320-Software-Test-Automation-QA-Project

# How can I ensure that my code, program, or software is functional and secure?
To ensure that my code and software are functional and secure, I focus on both thorough testing and sound development practices. I write unit tests using JUnit to verify that each class and method performs as expected, just like I did in the ContactService project where I tested every validation rule for IDs, names, and phone numbers. Regular testing throughout development helps identify bugs early, ensuring functionality aligns with requirements. For security, I apply input validation to prevent invalid or malicious data, enforce strict data length limits, and avoid exposing sensitive information. Additionally, I follow secure coding practices such as using private fields, encapsulation, and error handling to reduce vulnerabilities and make the code more reliable and resistant to misuse.

# How do I interpret user needs and incorporate them into a program?
I interpret user needs by carefully analyzing the project requirements and translating them into specific, testable functionalities. In this project, it was clear that users needed a way to manage contact information safely and consistently, so I implemented clear validation rules and methods for adding, updating, and deleting contacts. I also rely on requirement documents and feedback to ensure that the programâ€™s behavior matches real world expectations. By keeping the end user in mind, considering usability, accuracy, and reliability, I can design solutions that not only meet technical goals but also provide a seamless and intuitive user experience.

# How do I approach designing software?
When approaching software design, I start by breaking down the problem into smaller, manageable components and identifying the relationships between them. I often use object oriented design principles, such as encapsulation, inheritance, and modularity, to keep the system organized and maintainable. In the ContactService project, for instance, I created separate classes for the Contact object and the ContactService logic, allowing for easier testing and updates. I also plan ahead by mapping out how data flows through the program and how each part will interact. This structured approach ensures that the software is scalable, efficient, and easy to modify as new requirements or improvements arise.
